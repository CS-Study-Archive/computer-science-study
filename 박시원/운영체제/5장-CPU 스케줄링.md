# 5장-CPU 스케줄링

4장 프로세스 관리2 48분 14초부터 듣기

### CPU and I/O Bursts in Program Execution

어떤 프로그램이든 CPU를 실행하고 있는 단계와 I/O를 실행하는 단계를 번갈아가며 실행됨

사람과 상호작용이 많은 프로그램일 수록 해당 스테이지들이 많이 반복됨

컴퓨터 안의 작업은 CPU bound job과 I/O bound job으로 나뉘어져 섞여 있음

### CPU-burst Time의 분포

![image](https://user-images.githubusercontent.com/93081720/188294882-aa375601-69fb-4e19-97dd-894bd9aa9674.png)

그래프 해석

- I/O bound job이 CPU를 많이 쓰는 것처럼 오해할 수 있으나, 실제로 CPU를 많이 쓰는 것은 CPU bound job임
- I/O 작업을 위해 CPU를 수행하는 단계와 I/O를 수행하는 단계가 번갈아가면서 일어나서 CPU의 등장 빈도가 많아진 것이지, CPU를 많이 쓰는 것이 아님
- 오히려 CPU를 많이 쓰는 것은 CPU bound job이고, CPU를 한번 잡고 계속해서 쓰고 있으므로, CPU의 등장 빈도가 낮은 것임

### 프로세스의 특성 분류

- I/O bound process
  - CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 일

- CPU bound process
  - 계산 위주의 작업


### CPU Scheduler & Dispatcher

#### CPU Scheduler

Ready 상태의 프로세스 중에서 CPU를 줄 프로세스를 결정하는 것

#### Dispatcher

CPU를 누구한테 줄 지 결정했으면, CPU 제어권을 선택된 프로세스에게 넘기는 것(이 과정을 context switch라고 함)

#### CPU 스케줄링이 필요한 경우?

어떤 프로세스에 CPU를 줄 것인가? => 사람과 상호작용이 많은 프로세스에 CPU를 주는 것이 적합

공평, 효율적으로 CPU를 넘겨줘야함



프로세스에 다음과 같은 상태 변화가 있는 경우에 CPU 스케줄링이 필요하다

- Running → Blocked(예 - I/O를 요청하는 시스템 콜 발생 시)
- Running → Ready(예 - 할당 시간 만료로 타이머에 의한 인터럽트 발생시)
- Blocked → Ready (예 - I/O 완료 후 인터럽트; 단, I/O가 끝났다고 해서 무조건 CPU를 바로 넘기는 것은 아님)
- Terminate



### Preemptive & Nonpreemptive

#### Preemptive

강제로 빼앗음(선점)

현대 CPU체계는 거의 선점형을 사용하고 있음



#### Nonpreemptive

강제로 빼앗지 않고, 자진 반납함(비선점)



### 스케줄링 성능 척도(Scheduling Criteria)

- CPU 이용률
- 처리량
- 소요 시간
- 대기 시간
- 응답 시간
  - 응답 시간과 대기 시간의 차이 => 대기 시간은 모든 기다린 시간의 합이고. 응답 시간은 최초로 CPU를 얻기까지 기다린 시간의 합이다



## CPU 스케줄링 알고리즘

### FCFS(First Come First Serve)

선입선출 => 먼저 온 프로세스를 먼저 줌

비선점형이기 때문에 먼저 온 프로세스가 CPU를 오래 써버리면 뒤에 CPU를 별로 쓰지 않는 프로세스들이 많이 기다리게 되므로 비효율적임

- 컨보이 효과(convoy effect): CPU를 짧게 쓰는 프로세스들이 CPU를 길게 쓰는 프로세스를 기다려야하는 현상



### SJF(Shortes Job First)

CPU burst time이 짧은 프로세스에게 제일 먼저 스케줄링을 해줌

가장 작은 평균 대기 시간을 보장해줌

- 비선점 형식
  - 일단 현재 기준으로 짧은 프로세스에게 CPU를 주고 이후에 더 짧은 프로세스가 오더라도 현재 CPU를 사용 중이면 해당 프로세스를 대기시킴
- 선점 형식
  - 현재 수행 중인 프로세스보다 더 짧은 프로세스가 오면 CPU를 뺏어서 더 짧은 프로세스에게 줌

#### Starvation(기아 현상)

CPU 사용 시간이 상대적으로 긴 프로세스는 짧은 프로세스가 온다면 게속해서 짧은 프로세스를 위해서 기다려야하므로, 영원히 CPU를 받지 못하는 현상

- 다음번 CPU burst time을 예측(과거의 CPU burst time)하여 CPU 스케줄링을 하기도 하는 방식이 존재



### Priority Scheduling(우선순위 스케줄링)

높은 우선순위를 가진 프로세스에게 CPU를 할당

- 우선순위는 숫자형이고, 채택하는 우선순위의 종류는 시스템마다 다름

#### aging 기법

starvation 현상을 해결하기 위한 기법

아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여서 starvation을 방지함



### Round Robin(RR)

각 프로세스는 동일한 크기의 할당 시간(time quantum)을 가지는데, 할당 시간이 끝나면 CPU를 뺏기고 다시 대기 큐에 들어가서 CPU를 기다린다

응답 시간이 빨라진다는 장점이 있음



### Multi Level Queue

대기 큐가 여러 개 있고 각 큐에 우선순위가 있음

우선순위가 높은 큐가 비었으면 그 다음 우선순위를 가진 큐에서 기다리고 있는 프로세스에게 CPU를 줌

- 프로세스를 어떤 우선순위의 큐에 줄 것인가?
  - 큐에 대한 스케줄링이 필요해짐
- 우선순위가 낮은 계층의 큐는 기아현상이 발생할텐데 해결법은?
  - 큐간에 할당 시간을 주어서 해결하는 방식이 존재함

### Multi Level Feedback Queue

멀티 레벨 큐와 같은 구조이지만, 차이점은 프로세스가 다른 큐로 이동이 가능하다

- 처음 들어오는 프로세스는 어떤 큐에 삽입?
  - 일단은 우선 순위가 높은 큐에 삽입함
  - 그 다음 프로세스는 그 다음 우선순위를 가진 큐로 삽입함



## 멀티 프로세서 스케줄링

CPU가 여러 개일 떄의 스케줄링

- 동일한 프로세서인 경우
  - 프로세스를 큐에 한줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있음
  - 그러나 특정 프로세서에서만 수행되어야 하는 프로세스가 있는 경우 문제가 복잡해짐
- 로드 쉐어링
  - 일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘이 필요함
  - 별개의 큐를 두는 방법 vs. 공동 큐를 사용하는 방법이 있음
- SMP(Symmetric Multiprocessing)
  - 각 프로세서가 각자 알아서 스케줄링을 결정함
- Asymmetric Multiprocessing
  - 하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름



## 스레드 스케줄링

- Local Scheduling
  - 유저 레벨의 스케줄링
  - OS가 아닌 사용자 프로세스가 직접 어느 스레드에 줄지 결정
- Global Scheduling
  - 커널 레벨의 스케줄링
  - 커널의 단기 스케줄러(즉, OS)가 어떤 스레드를 스케줄할지 결정함